Важливою частиною розробки програмного забезпечення є створення компонентів, які мають не тільки добре описані та послідовні API, але і можуть бути reusable. Компоненти, які здатні працювати з даними які ви отримуєте сьогодні, також добре, як і з даними завтрашнього дня, дають вам гнучкі можливості для будування великих програмних систем.

У таких мовах, як C# та Java, однією з основних інструментів для створення багаторазових компонентів, є узагальнення (generics). Вони дають вам можливість створити компонент, який працює з різноманітними типами, як з одним. Це дає можливість користувачам використовувати ці компоненти з їх власними типами.

## "Hello World" узагальнень

Для початку створимо "hello world" узагальнень: функцію `identity`, яка просто повертає те, що в неї передано.

Без узагальнень, нам було би потрібно вказати конкретний тип нашій функції:

```typescript
function identity(arg: number): number {
    return arg;
}
```

Або прописати тип `any`:

```typescript
function identity(arg: any): any {
    return arg;
}
```

При використанні `any` функція може прийняти параметри любого типу, але у цьому випадку ми втрачаємо інформацію про повертаємий функцією тип. Якщо ми передаємо число, єдина інформація, яку ми маємо, — будь-який тип може бути повернутий.

Замість цього нам потрібен спосіб вказівки типу аргументу таким чином, щоб ми могли використовувати його для позначення типу, що повертається.

```typescript
function identity<T>(arg: T): T {
    return arg;
}
```

Ми додали новий тип змінної `T` до нашої функції. Це дозволить нам захопити тип, який зазначить користувач (наприклад, число), та використати цю інформацію у подальшому. Тут, ми знову використовуєм `T` для повертаємого типу. Тепер ми бачимо, що один і той же тип використовується для аргументу та повертаємого значення. Це дозволяє нам передати інформацію о типі з однієї "сторони" функції на іншу.

Ми говоримо, що ця версія фунції `identity` є узагальненою, оскільки вона працює в діапазоні типів. На відміну від використання `any`, ми не втрачаємо інформацію про типи.

Один раз описавши узагальнену функцію, ми можемо викликати її в один із двох способів. Перший спосіб це передати всі аргументи, включаючи їх типи, у функцію:

```typescript
var output = identity<string>("myString");  // повертаємим типом буде 'string'
```

Тут ми явно вказали, що `T` це рядок в одному з аргументів виклику функції, за допомогою кутових дужок (`<>`) навколо аргументу.

Інший спосіб є більш поширеним. Ми можемо використати /type argument inference/, це значить, що компілятор сам визначить та виставить тип для `T`, базуючись на тому, що ми передаємо у функцію:

```typescript
var output = identity("myString");  // повертаємим типом буде 'string'
```

Зазначте, що коли ми не вказуємо тип у кутових дужках (`<>`), компілятор просто дивиться на значення `"myString"`, та виставляє `T` потрібний тип. У той час, коли визначення типу дозволяє коду бути лаконічнішим та більш зручним для читання, вам може знадобитися явно вказати тип аргументу, як ми це робили в попередньому прикладі, якщо компілятор не зміг визначити тип автоматично.

## Працюємо зі змінними

Коли ви використовуєте узагальнення, то можете помітити, що при створенні таких функцій, як `dentity`, компілятор буде забезпечувати правильне використання типізованих параметрів у тілі функції. Саме тому ви повинні ставитися до них так, ніби вони можуть бути любого типу.

Роздивимось нашу функцію `identity`:

```typescript
function identity<T>(arg: T): T {
    return arg;
}
```

Що робити, якщо ви хочете виводити довжину аргументу `arg` у консоль при кожному виклику. Ми могли б спробувати написати це:

```typescript
function loggingIdentity<T>(arg: T): T {
    console.log(arg.length);  // Помилка: T не має .length
    return arg;
}
```

Але тоді компілятор видасть помилку про те що ми звертаємося до параметру `.length`, але ніде не вказано, що `arg` має такий параметр. Пам’ятаєте, ми казали раніше, що узагальнений параметр може бути будь якого типу, тому хтось може викликати цю функцію та передати `number`, який не має параметру `.length`.

Давайте припустимо, що ми справді хочемо використовувати цю функцію для роботи з масивами елементів `T`, а не напряму з об’єктом `T`. Якщо б ми працювали з масивами, тоді параметр `.length` повинен бути доступний. Ми можемо це описати також, як створюємо масиви інших типів:

```typescript
function loggingIdentity<T>(arg: T[]): T[] {
    console.log(arg.length);  // Масив має .length, помилка більше не виникає
    return arg;
}
```

Ви можете прочитати цей тип так: узагальнена функція `loggingIdentity` приймає типізований параметр `T` і аргумент `arg` , який має бути масивом цих `T`, та повертає масив таких `T`. Якщо ми передамо масив чисел, ми отримаємо масив чисел назад.

Є альтернативний запис цього прикладу:

```typescript
function loggingIdentity<T>(arg: Array<T>): Array<T> {
    console.log(arg.length);  // Масив має .length, помилка більше не виникає
    return arg;
}
```

Можливо, ви вже познайомились з цим в інших мовах. У наступному розділі розглянемо, як ви можете створювати свої власні узагальнені типи, такі як `Array<T>`.

## Узагальнені типи

У попередньому розділі ми створили функцію яка працює з діапазоном типів. У цьому розділі ми розглянемо типи самих функцій та процес створення інтерфейсу узагальнень.

Тип узагальнених функцій подібний до звичайних, де ви перелічуєте список параметрів:

```typescript
function identity<T>(arg: T): T {
    return arg;
}

var myIdentity: <T>(arg: T)=>T = identity;
```

Ми також можемо мати інше ім’я для узагальненого параметру, важливо лише щоб співпадали порядок та кількість параметрів:

```typescript
function identity<T>(arg: T): T {
    return arg;
}

var myIdentity: <U>(arg: U)=>U = identity;
```

Також ми можемо описати узагальнений тип функції за допомогою опису об’єкту:

```typescript
function identity<T>(arg: T): T {
    return arg;
}

var myIdentity: {<T>(arg: T): T} = identity;
```

Що приводить нас до написання нашого першого узагальненого інтерфейсу. Візьмемо літерал об’єкту з попереднього прикладу та перемістимо його в інтерфейс:

```typescript
interface GenericIdentityFn {
    <T>(arg: T): T;
}

function identity<T>(arg: T): T {
    return arg;
}

var myIdentity: GenericIdentityFn = identity;
```

Ми можемо вказати узагальнений параметр для всього інтерфейсу (`Dictionary<string>` замість просто `Dictionary`). Це дасть доступ до типу всім членам інтерфейсу.

```typescript
interface GenericIdentityFn<T> {
    (arg: T): T;
}

function identity<T>(arg: T): T {
    return arg;
}

var myIdentity: GenericIdentityFn<number> = identity;
```

Зверніть увагу, що наш приклад перетворився в дещо інше. Заміть описування узагальненої функції, тепер у нас звичайна функція у складі узагальненого інтерфейсу. Коли ми використовуємо `GenericIdentityFn`, нам потрібно вказати відповідний тип аргументу (тут `number`), який потрібно буде використовувати при виклику.

На додаток до узагальнених інтерфейсів, ми також можемо створювати узагальнені класи. Зверніть увагу, що неможливо створювати узагальнені `enum` та модулі.

## Узагальнені класи

Узагальнений клас має спільну форму з узагальненим інтерфейсом. Узагальнений параметр розташовується після назви класу у кутових дужках (<>).

```typescript
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

var myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
```

Це досить буквальне використання класу `GenericNumber`, але ви можете використовувати не тільки тип `number`, це може бути рядок або більш складний об’єкт.

```typescript
var stringNumeric = new GenericNumber<string>();
stringNumeric.zeroValue = "";
stringNumeric.add = function(x, y) { return x + y; };

alert(stringNumeric.add(stringNumeric.zeroValue, "test"));
```

Подібно до інтерфейсів, при вказанні параметру для всього класу, дозволяє нам переконатися, що всі члени класу працюють з тим же типом.

В розділі Класи (тут потрібен лінк на класи) ми з’ясували, що у класів є статична частина, та об’єктна. Узагальнені класи мають відношення тільки об’єктів, отож статичні члени не можуть отримати доступ до узагальнених параметрів.

## Обмежені узагальнення

Як ви пам’ятаєте з попередніх прикладів, інколи вам може знадобитись узагальнена функція, яка працює з набором типів, де ви маєте деяку інформацію про можливості цього набору. У нашому `loggingIdentity` прикладі, нам потрібно звернутися до параметру `arg.length`, але компілятор не вважає, що кожен тип має цей параметр, отож, він попередить нас про неможливість такого допущення.

```typescript
function loggingIdentity<T>(arg: T): T {
    console.log(arg.length);  //  Помилка: T не має .length
    return arg;
}
```

Замість того, щоб працювати з кожним типом, ми б хотіли обмежити цю функцію до роботи зі всіма типами, які мають параметр `.length`. Доки тип має цей параметр, ми дозволяємо його. Для цього ми повинні перерахувати наші вимоги до того, яким `T` може бути.

Ми створюємо інтерфейс, який описує наші обмеження. Ото ж у нас є інтерфейс, який має параметр `.length`, тепер ми можемо використовувати його з ключовим словом `extends`, щоб вказати наші обмеження:

```typescript
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length);  // Тепер ми знаемо, що об’єкт має параметр .length
    return arg;
}
```

Тепер, через обмеження узагальненої функції, тепер вона не бути приймати всі типи:

```typescript
loggingIdentity(3);  // Помилка, number не має параметру .length
```

Навпаки, тепер нам потрібно передавати лише ті типи, які мають необхідні параметри:

```typescript
loggingIdentity({length: 10, value: 3});
```

### Використання типів у обмежених узагальненнях

В деяких випадках, нам може бути корисним описати типізований параметр, який розширено іншим параметром:

```typescript
function find<T, U extends Findable<T>>(n: T, s: U) {   // помилка
  // ...
}
find (giraffe, myAnimals);
```

Ви можете домогтись цього, заміною типу параметру його обмеженнями. Перепишемо попередній приклад:

```typescript
function find<T>(n: T, s: Findable<T>) {
  // ...
}
find(giraffe, myAnimals);
```

Примітка: ці приклади не строго ідентичні, якщо у першому випадку повертаємий тип міг би бути `U`, то у другий не дозволяє нам це вказати.

### Використання типу класів

При створенні фабрик у TypeScript за допомогою узагальнень, важливо посилатися на тип класів у функціях конструктора:

```typescript
function create<T>(c: {new(): T; }): T {
    return new c();
}
```

Більш просунутий приклад використовує параметр прототипу для обмеження відносин між функцією конструктора та об’єктною стороною класу.

```typescript
class BeeKeeper {
    hasMask: boolean;
}

class ZooKeeper {
    nametag: string;
}

class Animal {
    numLegs: number;
}

class Bee extends Animal {
    keeper: BeeKeeper;
}

class Lion extends Animal {
    keeper: ZooKeeper;
}

function findKeeper<A extends Animal, K> (a: {new(): A;
    prototype: {keeper: K}}): K {

    return a.prototype.keeper;
}

findKeeper(Lion).nametag;  // typechecks!
```